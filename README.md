# CS-230
Coursework for the CS-230: Operating Platforms course at SNHU.
1. Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?
- The client for this project was the company The Gaming Room, and they were game developers who required software that could run a game that was based on an older show called *Win, Lose or Draw*. The software needed to display portions of an image to players on teams and to allow a team to guess what the picture depicted. Additionally, the software required the ability to run multiple game instances and to be accessible from nearly every device.
2. What did you do particularly well in developing this documentation?
- Based on the feedback from my professor, I did well at accounting for the fine details that would go into developing the software, whether it was the potential consequences of utilizing a specific operating system or certain security considerations that would need to be made during development. In doing this, I was able to understand the potential issues that the various options or issues, like the choice of operating system or a specific design constraint, would cause and to account for said choice or issue going forward.
3. What about the process of working through a design document did you find helpful when developing the code?
- By far, the decision to define the various design constraints was the most helpful before developing the code. Knowing the multiple choices and options that the client wanted me to implement changed the way that I programmed certain features of the program. For instance, instead of focusing on creating a singular game, having the knowledge that the client wanted to have multiple game instances running independently of one another allowed me to program the game as a reusable object, as opposed to a single-use object. Instead of having to go back and make this change later, and potentially create a ton of issues when doing so, having this information allowed me to design the program with it in mind from the beginning.
4. If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
- If I could rework one portion of this document, it would be my evaluation of the various operating systems. While I addressed the necessary information and provided the appropriate pros and cons for the project, knowing now that the application would be made into a web application would change the information I added to the evaluation. Instead of mainly focusing on developing each application on the operating system, I would split my focus on also addressing the use of web browsers and connections to the internet for the operating systems as well.
5. How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?
- To correctly interpret the user's needs and implement them into a software design, one needs to utilize the process of taking the user story or the information provided by the user and listing out the requirements, constraints, and a summary of the project based on the information. In doing this, the user has the chance to approve or add information that you will need during development, and ensures that the user's vision is understood. Without doing this, one could potentially design and create an entirely unrelated program for the user. Rather than wasting development time, getting approval and showing understanding of the user's problem and goals can ensure that the project will meet their expectations.
6. How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?
- My approach to designing this software was to utilize requirements and tasks for the project as a sort of plan, and from here, I began to implement the criteria one at a time while also running the project and checking for errors. In doing this, I ensured that I was never overwhelmed by working on elements of the project and that I only moved on to another aspect once I finished implementing and testing the current one I was on. In the future, I will definitely be adding to my processes, and I will start by utilizing pseudocode before I begin writing code. While having the plan and requirements was helpful, had I written pseudocode before developing the project, I would have had the chance to walk through each step of the process before writing code. This method would have made it easier to make changes or remove unnecessary steps, as having to perform these actions while coding costs more time and effort, since I had to ensure that no removal or editing of any current code created issues with other parts of the code.
